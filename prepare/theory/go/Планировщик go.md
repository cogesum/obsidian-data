## **Модель G-M-P (Goroutines-Machines-Processors)**

**G (Goroutine)** — легковесная горутина, представляющая собой единицу выполнения. Каждая горутина начинает с минимального стека в **2KB**, который динамически растет по мере необходимости. Горутины управляются полностью в пользовательском пространстве Go runtime'ом.
**M (Machine)** — поток операционной системы, который фактически выполняет код Go. M привязывается к P для выполнения горутин. Количество M может варьироваться, поскольку потоки могут блокироваться на системных вызовах. 
**P (Processor)** — логический процессор, представляющий ресурсы, необходимые для выполнения пользовательского кода Go. **Количество P равно GOMAXPROCS**. P можно рассматривать как CPU в планировщике ОС, содержащий состояние планировщика и распределителя памяти.

Задача планировщика — сопоставить G (код для выполнения), M (где выполнить) и P (права и ресурсы для выполнения). Когда M прекращает выполнение пользовательского кода Go (например, при входе в системный вызов), он возвращает свой P в пул неактивных P. 

## **Внутреннее устройство планировщика**
## **Архитектура очередей**
Планировщик использует **двухуровневую систему очередей**. **Глобальная очередь (Global Run Queue - GRQ)** — содержит горутины, которые еще не назначены P. Используется для горутин, готовых к выполнению, но не привязанных к конкретному процессору. **Локальные очереди (Local Run Queue - LRQ)** — каждый P имеет собственную локальную очередь, ограниченную 256 горутинами. Новые горутины приоритетно помещаются в локальную очередь. Если локальная очередь заполняется, половина горутин перемещается в глобальную очередь.

## **Алгоритм Work Stealing**
Go использует алгоритм **work stealing** начиная с версии 1.1. Принципы работы:
1. **Локальный поиск**: Планировщик сначала проверяет локальную очередь P
2. **Глобальная очередь**: 1/61 времени проверяется глобальная очередь для справедливости
3. **Кража работы**: Если локальная и глобальная очереди пусты, P пытается "украсть" половину горутин из локальной очереди другого случайно выбранного P
4. **Network poller**: Проверка событий сетевого ввода-вывода

Алгоритм поиска выполняемой горутины:
```go
runtime.schedule() {
    // только 1/61 времени проверять глобальную очередь
    // если не найдено, проверить локальную очередь
    // если не найдено, попытаться украсть у других P
    // если не найдено, проверить глобальную очередь
    // если не найдено, опросить network poller
}
```

## **GOMAXPROCS и влияние на производительность**
## **Основные принципы**

**GOMAXPROCS** определяет максимальное количество потоков ОС, которые могут одновременно выполнять пользовательский код Go. По умолчанию устанавливается равным количеству логических ядер CPU.

## **Влияние на производительность**
**Правильная настройка**:
- Оптимальное значение обычно равно количеству физических ядер
- Обеспечивает минимальное переключение контекста между потоками
- Максимизирует локальность данных и кэша

**Проблемы неправильной настройки**:
- **Завышенное значение**: Приводит к чрезмерному переключению контекста ОС, деградации производительности
- **Заниженное значение**: Недоиспользование доступных ресурсов CPU

### **Preemption**
**Preemption** (вытеснение) — это механизм в Go, который позволяет планировщику принудительно прерывать выполнение горутины, чтобы обеспечить справедливое распределение процессорного времени между всеми горутинами и не допустить ситуации, когда одна горутина монополизирует CPU и "голодают" остальные
С появлением preemption (начиная с Go 1.2, а в полной мере — с Go 1.14) планировщик Go стал вытесняющим: теперь он может принудительно остановить горутину даже посреди долгих вычислений, не дожидаясь, пока она сама уступит управление.
## **Механизм preemption**

**Мониторинг sysmon**
- Компонент sysmon отслеживает горутины, выполняющиеся более 10 мс
- При обнаружении долго выполняющейся горутины устанавливается флаг preempt
**Асинхронная preemption (Go 1.14+)**
1. sysmon обнаруживает горутину, выполняющуюся >10 мс
2. Отправляется сигнал SIGURG потоку, выполняющему эту горутину
3. Обработчик сигнала создает специальную горутину gsignal
4. gsignal останавливает выполняющуюся горутину и перепланирует её

## **Типы safe-point**
1. **Blocked safe-points**: Когда горутина заблокирована на синхронизации или системном вызове
2. **Synchronous safe-points**: Когда выполняющаяся горутина проверяет запрос на preemption
3. **Asynchronous safe-points**: В любой инструкции пользовательского кода, где горутина может быть безопасно приостановлена

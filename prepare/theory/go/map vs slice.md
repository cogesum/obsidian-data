## Поведение map и slice в Go: nil, неинициализированные, операции

### 1. Что такое nil и неинициализированные значения

В Go переменные типа `map` и `slice` по умолчанию имеют значение `nil`, если их явно не инициализировали через `make` или литерал.

```go
var m map[string]int    // nil map
var s []int             // nil slice
```

- **nil map** — переменная типа map, указывающая на "ничто".
- **nil slice** — переменная типа slice, указывающая на "ничто".

### 2. Операции с nil и неинициализированными map

| Операция                  | nil map поведение              | Почему?                                 |
|---------------------------|-------------------------------|-----------------------------------------|
| Чтение по ключу           | Вернёт zero value             | Без паники, просто нет значения         |
| Запись по ключу           | panic: assignment to entry in nil map | nil map не может быть изменён          |
| Итерация                  | Нет элементов, итерация безопасна | nil map ведёт себя как пустая map      |

**Примеры:**

```go
var m map[string]int // nil

x := m["foo"]        // x == 0, паники нет
m["foo"] = 42        // panic!
```

### 3. Операции с nil и неинициализированными slice

| Операция                  | nil slice поведение            | Почему?                                 |
|---------------------------|-------------------------------|-----------------------------------------|
| Чтение по индексу         | panic: index out of range     | Нет элементов, нельзя обратиться        |
| Добавление через append   | OK, создаётся новый slice     | append к nil slice работает корректно   |
| Итерация                  | Нет элементов, итерация безопасна | nil slice ведёт себя как пустой slice  |
| Длина/ёмкость             | 0/0                           | nil slice всегда имеет длину и ёмкость 0|

**Примеры:**

```go
var s []int // nil

fmt.Println(len(s))  // 0
fmt.Println(s[0])    // panic!
s = append(s, 1)     // OK, s теперь [1]
```

### 4. Ключевые различия между map и slice при nil

|                  | map                  | slice                    |
|------------------|----------------------|--------------------------|
| Чтение           | OK, zero value       | panic (если нет элементов)|
| Запись/добавление| panic                | OK через append          |
| Итерация         | OK, 0 элементов      | OK, 0 элементов          |
| Инициализация    | make/map literal     | make/slice literal/append|

### 5. Почему так устроено?

- **map** — nil map не выделяет памяти под хранилище пар ключ-значение, поэтому попытка записи вызывает панику.
- **slice** — nil slice не содержит массива, но append автоматически выделяет память, делая работу с nil slice удобной и безопасной.

### 6. Практические советы

- **map**: всегда инициализируйте через `make` перед записью:
  ```go
  m := make(map[string]int)
  m["foo"] = 1 // OK
  ```
- **slice**: можно использовать nil slice для append, но чтение по индексу до append вызовет панику.

### 7. Быстрая памятка

| Тип      | nil безопасно читать | nil безопасно писать | append к nil | Итерация по nil |
|----------|---------------------|---------------------|--------------|-----------------|
| map      | Да (zero value)     | Нет (panic)         | Нет          | Да (0 элементов)|
| slice    | Нет (panic)         | Нет (panic)         | Да           | Да (0 элементов)|

**Итог:**  
- Для map: nil — только для чтения и итерации, запись невозможна.
- Для slice: nil — нельзя читать по индексу, но можно append и итерировать.

Это фундаментальные различия, которые помогут избежать большинства ошибок при работе с этими структурами в Go.

Sources

## 1. Какие брокеры сообщений вы использовали? В чем их отличия?

**RabbitMQ**
- Основан на протоколе AMQP, поддерживает очереди и различные типы обменников (direct, topic, fanout).
- Отличается простотой интеграции, гибкой маршрутизацией и поддержкой подтверждений доставки.
- Хорошо подходит для классических очередей задач и сценариев, где важна гибкость маршрутизации.

**Apache Kafka**
- Ориентирован на обработку потоков данных, использует топики и партиционирование.
- Отличается высокой производительностью, горизонтальной масштабируемостью и гарантией хранения сообщений на диске.
- Предпочтителен для сценариев event sourcing, логирования, обработки больших объемов событий.

**NATS**
- Легковесный брокер с минимальной задержкой, поддерживает pub/sub, очереди и запрос-ответ.
- Отличается простотой развертывания, высокой скоростью и малой задержкой.
- Хорош для микросервисных архитектур, real-time коммуникаций, IoT.

## 2. Пример использования брокера сообщений для решения проблемы
В проекте с микросервисной архитектурой возникла проблема с перегрузкой одного из сервисов из-за всплесков трафика. Внедрение RabbitMQ позволило буферизовать входящие задачи:
- Продюсер отправляет задачи в очередь.
- Воркеры забирают задачи по мере готовности, что сгладило пики нагрузки и повысило устойчивость системы к временным сбоям отдельных сервисов.

## 3. Гарантированная доставка сообщений

- **At most once** — сообщение может быть потеряно, но не будет доставлено дважды. Не используется подтверждение доставки.
- **At least once** — сообщение будет доставлено минимум один раз, возможны дубликаты. Используются подтверждения (ack) и повторные попытки доставки.
- **Exactly once** — сообщение доставляется ровно один раз, сложная реализация (например, Kafka с transactional producer/consumer, идемпотентность на уровне приложения).
- **Реализация:**
- В RabbitMQ: включить подтверждения (ack) на стороне consumer, использовать dead letter queue для неудачных сообщений. 
- В Kafka: использовать consumer group с commit offset, transactional producer для exactly once.

## 4. Retry и обработка ошибок

- **Автоматический retry:**
    - В RabbitMQ — использовать dead letter exchange и повторную публикацию сообщений с задержкой (например, через отдельную очередь с TTL).
    - В Kafka — consumer повторяет обработку сообщения до успеха, offset не коммитится до успешной обработки.
        
- **Обработка ошибок:**
    - Логировать ошибочные сообщения.
    - Перемещать "ядовитые" сообщения в dead letter queue для последующего анализа.
## 5. Мониторинг и масштабирование потребителей

- **Мониторинг:**
    - RabbitMQ: встроенная панель управления, метрики очередей и потребителей, интеграция с Prometheus.
    - Kafka: JMX-метрики, инструменты мониторинга (Kafka Manager, Prometheus, Grafana).
        
- **Масштабирование:**
    - RabbitMQ: добавление воркеров, горизонтальное масштабирование через кластеры.
    - Kafka: увеличение числа партиций и consumer group, автоматическое распределение нагрузки между consumers.
## 6. Решение проблемы "consumer lag" в Kafka

- **Consumer lag** — отставание потребителя от актуального конца топика.
    
- **Способы решения:**
    
    - Увеличить число потребителей в группе.
        
    - Оптимизировать логику обработки сообщений (уменьшить время обработки).
        
    - Увеличить ресурсы (CPU, память) для consumers.
        
    - Пересмотреть партиционирование топика для лучшего распределения нагрузки.
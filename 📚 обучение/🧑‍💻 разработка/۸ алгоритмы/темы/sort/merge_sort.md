---
tags:
  - program
  - algos
  - sort
---
![[Pasted image 20250708134729.png]]
- также использует подход "разделяй и влавствуй". Но в итоге, он объединяет итоговый массив в одну структуру

1) делим множество на две части, пока не останется один элемент
2) затем сравниваем элемент каждой пары и сливаем их в один отсортированный массив
3)  повторяем второй шаг, пока не получим готовый отсортировнный массив

! Один из недостатков - доп память для хранения временных массивов.
! Он гарантирует временную сложность. O(log n) во всех случаях, и O(n) памяти.

---
**Внешняя сортировка**. При сортировке данных, которые не помещаются в оперативную память, алгоритм может обрабатывать их по частям, сохраняя промежуточные результаты на диске.

**Сортировка связанных списков**. Благодаря своей способности легко работать с рекурсивными структурами, Merge Sort подходит для сортировки связанных списков, где вставка и удаление элементов из середины могут быть выполнены за константное время.

**Оптимизация в многоядерных системах**. Процесс рекурсивного деления массива на подмассивы можно распараллелить, что делает Merge Sort хорошим выбором для многопоточных систем и обработки данных на кластерах.

```go
func separate(arr []int) []int {  
    if len(arr) == 1 {  
       return arr  
    }  
  
    // first step, separate  
    m := len(arr) / 2  
    first := separate(arr[:m])  
    last := separate(arr[m:])  
  
    merged := make([]int, 0, len(arr))  
    f, s := 0, 0  
  
    for f < len(first) && s < len(last) {  
       if first[f] < last[s] {  
          merged = append(merged, first[f])  
          f++  
       } else {  
          merged = append(merged, last[s])  
          s++  
       }  
    }  
  
    if f < len(first) {  
       merged = append(merged, first[f:]...)  
    }  
  
    if s < len(last) {  
       merged = append(merged, last[s:]...)  
    }  
  
    return merged  
}
```
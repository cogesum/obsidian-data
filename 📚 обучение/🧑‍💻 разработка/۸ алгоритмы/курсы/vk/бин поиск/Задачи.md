#### "Найти корень числа"
Написать функцию, которая находит корень числа или ближайшее подходящее наименьшее целое число. 9 -3, 21 - 4.
#### "Дипломы"
Петя активно учавстует во всех олимпиадах по математике и физике. Он накопил 9 дипломов, которые лежали на столе, и он не знал, что с ними делать. И вот решил разместить их на квадратной доске.
Дано: 9 прямоугольников 3 на 4, котрые надо разместить на квадратной поверхности
Надо: найти минимальную сторону квадртата для разменещия всех дипломов.

Что делает этот алгоритм?
1. **l** — левая граница бинпоиска. Минимальная сторона квадрата не может быть меньше максимального из `w` и `h`.
2. **r** — правая граница. Грубая верхняя оценка: если положить все прямоугольники в линию.
3. Внутри цикла проверяется, сколько прямоугольников помещается в квадрат размера `mid x mid`:
```go
res := (mid / w) * (mid / h)
```

Это вычисляет, сколько прямоугольников `w x h` можно разместить плотно по сетке в квадрате `mid x mid`.


```go
func Diploma(w, h, n int) int {  
    l := max(w, h) // это квадрта, значит должны брать максимальный размер. Если у тебя прямоугольник 3x4, то в квадрате меньше 4 ничего не поместится → max(3, 4) = 4  
    r := l * n     // находим возможный максимум, как крайнюю границу. У нас 9 прямоугольников 3x4 → каждый занимает минимум 4 по высоте. Если положить их "в столбик", получится высота 9*4 = 36 → квадрат должен быть как минимум 36x36  
  
    for l+1 < r {  
       mid := l + (r-l)/2  
       res := (mid / w) * (mid / h)  
       if res < n {  
          l = mid  
       } else {  
          r = mid  
       }  
    }  
  
    return r  
}
```
#### "Очень легкая"


### Поиск позиции
```
Дан отсортированный по возрастанию массив целых чисел и заданное число. Если заданное число уже находится в массиве, верните его индекс. Если числа в массиве нет, верните индекс, где оно должно находиться, чтобы сохранить порядок сортировки.
```
``
```go
package main  
  
import (  
    "bufio"  
    "fmt"    "os"    "strconv"    "strings")  
  
func findPosition(nums []int, target int) int {  
	if len(nums) == 0 {
		return 0
	}
	  
    l, r := 0, len(nums)-1  
  
    for l <= r {  
       m := l + (r-l)/2  
       if nums[m] == target {  
          fmt.Printf("%d", m)  
          return  
       }  
  
       if nums[m] > target {  
          r = m - 1  
       } else {  
          l = m + 1  
       }  
    }  
  
    fmt.Printf("%d", l)  
}
```
```go

// write a program, ulrl... 
// worker pool ... MAX N grourotine
// at most N goroutines
// url => body , result in command line ... 


type workerPool struct { 
    resCh chan string
    workerCh chan struct{}
    maxWorkers int64
}


func NewWorkerPool(ctx context, N int64) *workerPool {
    

}

// closing result channel?
func (w *workerPool) PutTask(ctx context.Context, u string) {  
    select {
        case <-ctx.Done():
            return
        case workerCh <- struct{}{}:
    }
    
    go func() {
        defer func() {
            <-workerCh
        }() 
        // ... GET, marshal, body
        body := u.body
        resCh <- body
    }()
}

// fixed workpool

func main () {
    ctx := context.WithTimeout(time.Second * 500)
    wp := NewWorkerPool(ctx, 32)
    
    
    urls := []slice{"http://ya.ru", ""}

    for _, u := range urls {
        wp.PuTask(u)
    }
    
    //  wp.Close() //here no tasks we no it !!!
    // for range := wp.Results()
}


// LoadPtr
// StoreStr 

// make a code, StorePtr map , h , run with race
// With LoadPtr , run with race
// generics example 


```

